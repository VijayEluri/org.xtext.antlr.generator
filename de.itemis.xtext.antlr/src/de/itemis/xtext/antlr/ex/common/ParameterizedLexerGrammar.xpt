«REM»
/*******************************************************************************
 * Copyright (c) 2008 itemis AG (http://www.itemis.eu) and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 *******************************************************************************/
«ENDREM»

«IMPORT org::eclipse::xtext»
«IMPORT de::itemis::xtext::antlr::ex::common»

«EXTENSION org::eclipse::xtext::generator::Naming»
«EXTENSION de::itemis::xtext::antlr::AntlrGrammar»
«EXTENSION de::itemis::xtext::antlr::ex::common::Common»
«EXTENSION org::eclipse::xtext::EcoreUtils»


«DEFINE grammar(de::itemis::xtext::antlr::AntlrOptions options, AntlrFragmentHelper helper, String lexerGrammarFileName, String superclass) FOR Grammar»
/*
«fileHeader()»
*/
lexer grammar «lexerGrammarFileName.toSimpleName()»;

«IF options.backtrackLexer-»
options {
	backtrack=true;
	memoize=true;
}
«ENDIF-»

@header {
package «lexerGrammarFileName.toJavaPackage()»;

// Hack: Use our own Lexer superclass by means of import. 
// Currently there is no other way to specify the superclass for the lexer.
import «superclass»;
}

«IF options.backtrackLexer-»
«EXPAND backtrackingAntlrRules(helper)»
«ELSE-»
«EXPAND antlrRules(helper)»
«ENDIF-»
«ENDDEFINE»

«DEFINE antlrRules(AntlrFragmentHelper helper) FOR Grammar»
«EXPAND keywords»
«EXPAND rule(helper) FOREACH allTerminalRules()»
«ENDDEFINE»

«DEFINE keywords FOR Grammar»
«FOREACH allParserRules().select(e|isCalled(this,e)).union(allEnumRules().select(e|isCalled(this,e))).allContents().typeSelect(Keyword).collect(e|e.value).toSet().sortBy(e|e).sortBy(e|e.length*-1) AS kw»
«getKeywordRuleName(kw)» : '«kw.toAntlrString()»';
«ENDFOREACH»
«ENDDEFINE»

«DEFINE rule(AntlrFragmentHelper helper) FOR TerminalRule»
«IF !helper.isSyntheticTerminalRule(this)-»
«ruleName()» : «toLexerBody()»;
«ELSE-»
fragment «ruleName()» : ;
«ENDIF-»
«ENDDEFINE»

«DEFINE backtrackingAntlrRules(AntlrFragmentHelper helper) FOR Grammar»
«EXPAND backtrackingKeywords»
«EXPAND backtrackingRule(helper) FOREACH allTerminalRules()»
«ENDDEFINE»

«DEFINE backtrackingKeywords FOR Grammar»
SYNTHETIC_ALL_KEYWORDS :
«FOREACH allParserRules().select(e|isCalled(this,e)).union(allEnumRules().select(e|isCalled(this,e))).allContents().typeSelect(Keyword).collect(e|e.value).toSet().sortBy(e|e).sortBy(e|e.length) AS kw ITERATOR it»
	(FRAGMENT_«getKeywordRuleName(kw)»)=> FRAGMENT_«getKeywordRuleName(kw)» {$type = «getKeywordRuleName(kw)»; } «IF !it.lastIteration || !allTerminalRules().isEmpty»|
	«ENDIF-» 
«ENDFOREACH-»
«FOREACH allTerminalRules() AS rule ITERATOR  it-»
	(FRAGMENT_«rule.ruleName()»)=> FRAGMENT_«rule.ruleName()» {$type = «rule.ruleName()»; } «IF !it.lastIteration»|
«ENDIF-»
«ENDFOREACH»;
«FOREACH allParserRules().select(e|isCalled(this,e)).union(allEnumRules().select(e|isCalled(this,e))).allContents().typeSelect(Keyword).collect(e|e.value).toSet().sortBy(e|e).sortBy(e|e.length) AS kw»
fragment «getKeywordRuleName(kw)» : '«kw.toAntlrString()»';
fragment FRAGMENT_«getKeywordRuleName(kw)» : '«kw.toAntlrString()»';
«ENDFOREACH»
«ENDDEFINE»

«DEFINE backtrackingRule(AntlrFragmentHelper helper) FOR TerminalRule»
fragment «ruleName()» : ;
«IF !helper.isSyntheticTerminalRule(this)-»
fragment FRAGMENT_«ruleName()» : «toLexerBody()»;
«ENDIF-»
«ENDDEFINE»

