«REM»
/*******************************************************************************
 * Copyright (c) 2008 itemis AG (http://www.itemis.eu) and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 *******************************************************************************/
«ENDREM»

«IMPORT org::eclipse::xtext»
«IMPORT org::eclipse::emf::ecore»
«IMPORT de::itemis::xtext::antlr»
«IMPORT de::itemis::xtext::antlr::ex::common»

«EXTENSION org::eclipse::xtext::generator::Naming»
«EXTENSION de::itemis::xtext::antlr::AntlrGrammar»
«EXTENSION de::itemis::xtext::antlr::ex::common::Common»
«EXTENSION org::eclipse::xtext::EcoreUtils»

«DEFINE grammar(AntlrOptions options, AntlrFragmentHelper helper) FOR Grammar»
«FILE helper.getParserGrammarFileName(this).asPath()+".g" SRC_GEN-»
/*
«fileHeader()»
*/
parser grammar «helper.getParserGrammarFileName(this).toSimpleName()»;

options {
	tokenVocab=«helper.getLexerGrammarFileName(this).toSimpleName()»;
	superClass=AbstractInternalAntlrParser;
	«IF options.backtrack-»
	backtrack=true;
	«ENDIF-»
	«IF options.memoize-»
	 memoize=true;
	«ENDIF-»
	«IF options.k>=0»
	 k=«options.k»;
	«ENDIF»
}

@header {
package «helper.getParserGrammarFileName(this).toJavaPackage()»; 

import java.io.InputStream;
import org.eclipse.xtext.*;
import org.eclipse.xtext.parser.*;
import org.eclipse.xtext.parser.impl.*;
import org.eclipse.xtext.parsetree.*;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.emf.ecore.EObject;
«IF !allEnumRules().isEmpty-»
import org.eclipse.emf.common.util.Enumerator;
«ENDIF-»
import org.eclipse.xtext.parser.antlr.AbstractInternalAntlrParser;
import org.eclipse.xtext.parser.antlr.XtextTokenStream;
import org.eclipse.xtext.parser.antlr.XtextTokenStream.HiddenTokens;
import org.eclipse.xtext.parser.antlr.AntlrDatatypeRuleToken;
import org.eclipse.xtext.conversion.ValueConverterException;
import «gaFQName()»;

}

@members {
 
 	private «gaSimpleName()» grammarAccess;
 	
    public «helper.getInternalParserClassName(this).toSimpleName()»(TokenStream input, IAstFactory factory, «gaSimpleName()» grammarAccess) {
        this(input);
        this.factory = factory;
        registerRules(grammarAccess.getGrammar());
        this.grammarAccess = grammarAccess;
    }
    
    @Override
    protected InputStream getTokenFile() {
    	ClassLoader classLoader = getClass().getClassLoader();
    	return classLoader.getResourceAsStream("«helper.getParserGrammarFileName(this).asPath()».tokens");
    }
    
    @Override
    protected String getFirstRuleName() {
    	return "«allParserRules().first().name»";	
   	} 
}

@rulecatch { 
    catch (RecognitionException re) { 
        recover(input,re); 
        appendSkippedTokens();
    } 
}
«EXPAND antlrRules(options)»
«ENDFILE»
«ENDDEFINE»

«DEFINE antlrRules(AntlrOptions options) FOR Grammar»
«EXPAND rule(this, options) FOREACH allParserRules()»
«EXPAND rule(this, options) FOREACH allEnumRules()»
«ENDDEFINE»


«DEFINE rule(Grammar original, AntlrOptions options) FOR ParserRule»
«IF isCalled(original,this)»
«IF !isDatatypeRule()»
// Entry rule «entryRuleName()»
«entryRuleName()» returns [EObject current=null] :
	{ currentNode = «EXPAND createCompositeNode» }
	 iv_«ruleName()»=«ruleName()» 
	 { $current=$iv_«ruleName()».current; } 
	 EOF 
;

// Rule «name»
«ruleName()» returns [EObject current=null] 
    @init { EObject temp=null; setCurrentLookahead(); resetLookahead(); 
«IF definesHiddenTokens-»
		HiddenTokens myHiddenTokenState = ((XtextTokenStream)input).setHiddenTokens(«FOREACH hiddenTokens AS hidden SEPARATOR ", "»"«hidden.ruleName()»"«ENDFOREACH-»);
«ENDIF-»    
    }
    @after { resetLookahead(); 
    	lastConsumedNode = currentNode;
«IF definesHiddenTokens-»
		myHiddenTokenState.restore();
«ENDIF-»
    }:
    «EXPAND ebnf(original, options) FOR this.alternatives»;
«ELSE»
// Entry rule «entryRuleName()»
«entryRuleName()» returns [String current=null] :
	{ currentNode = «EXPAND createCompositeNode» } 
	 iv_«ruleName()»=«ruleName()» 
	 { $current=$iv_«ruleName()».current.getText(); }  
	 EOF 
;

// Rule «name»
«ruleName()» returns [AntlrDatatypeRuleToken current=new AntlrDatatypeRuleToken()] 
    @init { setCurrentLookahead(); resetLookahead(); 
«IF definesHiddenTokens-»
		HiddenTokens myHiddenTokenState = ((XtextTokenStream)input).setHiddenTokens(«FOREACH hiddenTokens AS hidden SEPARATOR ", "»"«hidden.ruleName()»"«ENDFOREACH-»);
«ENDIF-» 
    }
    @after { resetLookahead(); 
	    lastConsumedNode = currentNode;
«IF definesHiddenTokens-»
		myHiddenTokenState.restore();
«ENDIF-» 
    }:
   «EXPAND dataTypeEbnf(original) FOR this.alternatives»
    ;
«ENDIF»
«ENDIF»
«ENDDEFINE»

«DEFINE rule(Grammar original, AntlrOptions options) FOR EnumRule»
«IF isCalled(original,this)»
// Rule «name»
«ruleName()» returns [Enumerator current=null] 
    @init { setCurrentLookahead(); resetLookahead(); }
    @after { resetLookahead(); 
    	lastConsumedNode = currentNode;
    }:
    «EXPAND ebnf(original, options) FOR this.alternatives»;
«ENDIF»
«ENDDEFINE»

«DEFINE ebnf2(Grammar grammar, AntlrOptions options) FOR EnumLiteralDeclaration-»
    «grammar.getKeywordRuleName(literal.value)»
	{
        $current = grammarAccess.«grammarElementAccess(this)».getEnumLiteral().getInstance();
        «EXPAND createLeafNode» 
    }
«ENDDEFINE»

«DEFINE ebnf(Grammar grammar, AntlrOptions options) FOR AbstractElement-»
«IF mustBeParenthesized()»(«EXPAND ebnf2(grammar, options)»)«ELSE»«EXPAND ebnf2(grammar, options)»«ENDIF»«cardinality-»
«ENDDEFINE»

«DEFINE dataTypeEbnf(Grammar grammar) FOR AbstractElement-»
«IF mustBeParenthesized()»(«EXPAND dataTypeEbnf2(grammar)»)«ELSE»«EXPAND dataTypeEbnf2(grammar)»«ENDIF»«cardinality-»
«ENDDEFINE»

«DEFINE dataTypeEbnf2(Grammar grammar) FOR AbstractElement»ERROR «metaType.name» not matched«ENDDEFINE»

«DEFINE dataTypeEbnf2(Grammar grammar) FOR Alternatives-»«EXPAND dataTypeEbnf(grammar) FOREACH groups SEPARATOR '\n    |'»«ENDDEFINE»

«DEFINE dataTypeEbnf2(Grammar grammar) FOR Group»«EXPAND dataTypeEbnf(grammar) FOREACH tokens»«ENDDEFINE»

«DEFINE dataTypeEbnf2(Grammar grammar) FOR Keyword»
	kw=«grammar.getKeywordRuleName(value)» 
    {
        $current.merge(kw);
        «EXPAND createLeafNode» 
    }
«ENDDEFINE»

«DEFINE dataTypeEbnf2(Grammar grammar) FOR RuleCall-»
«IF (ParserRule.isInstance(rule) || EnumRule.isInstance(rule)) && !isAssigned()»
    { 
        currentNode=«EXPAND createCompositeNode» 
    }
«ENDIF-»
    «localVar()»=«rule.ruleName()-»
    {
		$current.merge(«localVar()»);
    }
«IF (ParserRule.isInstance(rule) || EnumRule.isInstance(rule)) && !isAssigned()»
    { 
        currentNode = currentNode.getParent();
    }
«ENDIF-»
«IF TerminalRule.isInstance(rule)»
    { 
    «EXPAND createLeafNode» 
    }
«ENDIF-»
«ENDDEFINE»

«DEFINE ebnf2(Grammar grammar, AntlrOptions options) FOR AbstractElement»ERROR «metaType.name» not matched«ENDDEFINE»

«DEFINE ebnf2(Grammar grammar, AntlrOptions options) FOR Alternatives-»«EXPAND ebnf(grammar, options) FOREACH groups SEPARATOR '\n    |'»«ENDDEFINE»

«DEFINE ebnf2(Grammar grammar, AntlrOptions options) FOR Group»«EXPAND ebnf(grammar, options) FOREACH tokens»«ENDDEFINE»

«DEFINE crossrefEbnf(Grammar grammar, CrossReference ref) FOR AbstractElement-»
«ERROR "crossrefEbnf is not supported for AbstractElement"»
«ENDDEFINE»

«DEFINE crossrefEbnf(Grammar grammar, CrossReference ref) FOR Alternatives-»
		(«EXPAND crossrefEbnf(grammar, ref) FOREACH groups SEPARATOR '\n    |'»)
«ENDDEFINE»

«DEFINE crossrefEbnf(Grammar grammar, CrossReference ref) FOR RuleCall-»
«EXPAND crossrefEbnf(grammar, ref) FOR rule-»
«ENDDEFINE»

«DEFINE crossrefEbnf(Grammar grammar, CrossReference ref) FOR AbstractRule-»
«ERROR "crossrefEbnf is not supported for AbstractRule"»
«ENDDEFINE»

«DEFINE crossrefEbnf(Grammar grammar, CrossReference ref) FOR ParserRule-»
«IF !isDatatypeRule()-»
«ERROR "crossrefEbnf is not supported for ParserRule that is not a datatype rule"»
«ELSE-»
		{ 
	        currentNode=«EXPAND createCompositeNode FOR ref» 
	    }
		«ruleName()-»
		{ 
	        currentNode = currentNode.getParent();
	    }
«ENDIF-»
«ENDDEFINE»

«DEFINE crossrefEbnf(Grammar grammar, CrossReference ref) FOR EnumRule-»
		{ 
	        currentNode=«EXPAND createCompositeNode FOR ref» 
	    }
		«ruleName()-»
		{ 
	        currentNode = currentNode.getParent();
	    }
«ENDDEFINE»

«DEFINE crossrefEbnf(Grammar grammar, CrossReference ref) FOR TerminalRule-»
	«ruleName()»
	{
		«EXPAND createLeafNode FOR ref» 
	}
«ENDDEFINE»

«DEFINE assignmentEbnf(Grammar grammar, Assignment assignment, AntlrOptions options) FOR AbstractElement-»
		«assignment.localVar(this)»=«EXPAND ebnf(grammar, options)» 
	    {
	        if ($current==null) {
	            $current = factory.create(grammarAccess.«assignment.containingParserRule().grammarElementAccess()».getType().getClassifier());
	            associateNodeWithAstElement(currentNode, $current);
	        }
	        «REM»the use of input.LT(-1) in the following line is a workaroudn for a bug of antlr, where assignements of alternative keywords are ignored when there are actions«ENDREM»
	        try {
	       		«assignment.setOrAdd()»($current, "«assignment.feature»", «
	        		IF assignment.isBoolean()»true«
	        		ELSE»«assignment.localVar(this)»«
	        		ENDIF», «assignment.terminal.toStringLiteral()», lastConsumedNode);
	        } catch (ValueConverterException vce) {
				handleValueConverterException(vce);
	        }
	    }
«ENDDEFINE»

«DEFINE assignmentEbnf(Grammar grammar, Assignment assignment, AntlrOptions options) FOR Group-»
«ERROR "assignmentEbnf is not supported for Group"»
«ENDDEFINE»

«DEFINE assignmentEbnf(Grammar grammar, Assignment assignment, AntlrOptions options) FOR Assignment-»
«ERROR "assignmentEbnf is not supported for Assignment"»
«ENDDEFINE»

«DEFINE assignmentEbnf(Grammar grammar, Assignment assignment, AntlrOptions options) FOR Action-»
«ERROR "assignmentEbnf is not supported for Action"»
«ENDDEFINE»

«DEFINE assignmentEbnf(Grammar grammar, Assignment assignment, AntlrOptions options) FOR Alternatives-»
(
«EXPAND assignmentEbnf(grammar, assignment, options) FOREACH groups SEPARATOR '\n    |'»
)
«ENDDEFINE»

«DEFINE assignmentEbnf(Grammar grammar, Assignment assignment, AntlrOptions options) FOR RuleCall-»
«EXPAND assignmentEbnf(assignment, this) FOR rule-»
«ENDDEFINE»

«DEFINE assignmentEbnf(Assignment assignment, RuleCall call) FOR AbstractRule-»
«ERROR "assignmentEbnf is not supported for AbstractRule"»
«ENDDEFINE»

«DEFINE assignmentEbnf(Assignment assignment, RuleCall call) FOR ParserRule-»
		{ 
	        currentNode=«EXPAND createCompositeNode FOR call» 
	    }
		«assignment.localVar(call)»=«ruleName()-»
		{
	        if ($current==null) {
	            $current = factory.create(grammarAccess.«assignment.containingParserRule().grammarElementAccess()».getType().getClassifier());
	            associateNodeWithAstElement(currentNode.getParent(), $current);
	        }
	        try {
	       		«assignment.setOrAdd()»(
	       			$current, 
	       			"«assignment.feature»",
	        		«IF assignment.isBoolean()»true«ELSE»«assignment.localVar(call)»«ENDIF», 
	        		«call.toStringLiteral()», 
	        		currentNode);
	        } catch (ValueConverterException vce) {
				handleValueConverterException(vce);
	        }
	        currentNode = currentNode.getParent();
	    }
«ENDDEFINE»

«DEFINE assignmentEbnf(Assignment assignment, RuleCall call) FOR EnumRule-»
		{ 
	        currentNode=«EXPAND createCompositeNode FOR call» 
	    }
		«assignment.localVar(call)»=«ruleName()-»
		{
	        if ($current==null) {
	            $current = factory.create(grammarAccess.«assignment.containingParserRule().grammarElementAccess()».getType().getClassifier());
	            associateNodeWithAstElement(currentNode.getParent(), $current);
	        }
	        try {
	       		«assignment.setOrAdd()»(
	       			$current, 
	       			"«assignment.feature»",
	        		«IF assignment.isBoolean()»true«ELSE»«assignment.localVar(call)»«ENDIF», 
	        		«call.toStringLiteral()», 
	        		currentNode);
	        } catch (ValueConverterException vce) {
				handleValueConverterException(vce);
	        }
	        currentNode = currentNode.getParent();
	    }
«ENDDEFINE»

«DEFINE assignmentEbnf(Assignment assignment, RuleCall call) FOR TerminalRule-»
		«assignment.localVar(call)»=«ruleName()»
		{
			«EXPAND createLeafNode FOR call» 
		}
		{
	        if ($current==null) {
	            $current = factory.create(grammarAccess.«assignment.containingParserRule().grammarElementAccess()».getType().getClassifier());
	            associateNodeWithAstElement(currentNode, $current);
	        }
	        try {
	       		«assignment.setOrAdd()»(
	       			$current, 
	       			"«assignment.feature»",
	        		«IF assignment.isBoolean()»true«ELSE»«assignment.localVar(call)»«ENDIF», 
	        		«call.toStringLiteral()», 
	        		lastConsumedNode);
	        } catch (ValueConverterException vce) {
				handleValueConverterException(vce);
	        }
	    }
«ENDDEFINE»

«DEFINE assignmentEbnf(Grammar grammar, Assignment assignment, AntlrOptions options) FOR CrossReference-»
«IF options.backtrack-»
		{ 
		  /* 
		  dummy action to prevent antlr bug: if backtracking is enabled, antlr will
		  create synpreds that cannot be compiled in some rare cases
		  */ 
		}
«ENDIF-»
		{
			if ($current==null) {
	            $current = factory.create(grammarAccess.«assignment.containingParserRule().grammarElementAccess()».getType().getClassifier());
	            associateNodeWithAstElement(currentNode, $current);
	        }
        }
		«EXPAND crossrefEbnf(grammar, this) FOR terminal-»
«ENDDEFINE»

«DEFINE ebnf2(Grammar grammar, AntlrOptions options) FOR Assignment»
(
«EXPAND assignmentEbnf(grammar, this, options) FOR terminal»
)
«ENDDEFINE»

«DEFINE ebnf2(Grammar grammar, AntlrOptions options) FOR CrossReference»
«ERROR "ebnf2(Grammar grammar) is not supported for CrossReference"»
«ENDDEFINE»

«DEFINE ebnf2(Grammar grammar, AntlrOptions options) FOR Action»
    { 
        temp=factory.create(grammarAccess.«grammarElementAccess()».getType().getClassifier());
«IF feature != null-»
        try {
        	factory.«setOrAdd()»(temp, "«feature»", $current, null /*ParserRule*/, currentNode);
        } catch(ValueConverterException vce) {
        	handleValueConverterException(vce);
        }
«ENDIF-»
        $current = temp; 
        temp = null;
        «EXPAND insertCompositeNode» 
        associateNodeWithAstElement(currentNode, $current); 
    }
«ENDDEFINE»

«DEFINE ebnf2(Grammar grammar, AntlrOptions options) FOR Keyword»
	«grammar.getKeywordRuleName(value)» 
    {
        «EXPAND createLeafNode» 
    }
«ENDDEFINE»

«DEFINE ebnf2(Grammar grammar, AntlrOptions options) FOR RuleCall-»
«IF (ParserRule.isInstance(rule) && !isDatatypeRule((ParserRule)rule) || EnumRule.isInstance(rule)) && !isAssigned()»
    { 
        currentNode=«EXPAND createCompositeNode» 
    }
    «localVar()»=«ENDIF-»
«rule.ruleName()-»
«IF (ParserRule.isInstance(rule) && !isDatatypeRule((ParserRule)rule) || EnumRule.isInstance(rule)) && !isAssigned()»
    { 
        $current = $«localVar()».current; 
        currentNode = currentNode.getParent();
    }
«ENDIF-»
«IF TerminalRule.isInstance(rule)»
    { 
    «EXPAND createLeafNode» 
    }
«ENDIF-»
«ENDDEFINE»

«DEFINE createCompositeNode FOR EObject
    »createCompositeNode(grammarAccess.«
    grammarElementAccess(this)
    », currentNode);«
ENDDEFINE»

«DEFINE insertCompositeNode FOR Action
    »CompositeNode newNode = createCompositeNode(grammarAccess.«
    grammarElementAccess(this)
    », currentNode.getParent());
    newNode.getChildren().add(currentNode);
    moveLookaheadInfo(currentNode, newNode);
    currentNode = newNode;«
ENDDEFINE»

«DEFINE createLeafNode FOR EObject
    »createLeafNode(grammarAccess.«
    grammarElementAccess(this)
    », «
    IF isAssigned()
        »"«
        containingAssignment().feature
        »"«
    ELSE
        »null«
    ENDIF
    »);«
ENDDEFINE»

