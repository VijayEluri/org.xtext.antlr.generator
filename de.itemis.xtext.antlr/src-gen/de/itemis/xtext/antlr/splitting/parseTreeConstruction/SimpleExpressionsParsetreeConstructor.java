/*
* generated by Xtext
*/
package de.itemis.xtext.antlr.splitting.parseTreeConstruction;

import org.eclipse.emf.ecore.*;
import org.eclipse.xtext.*;
import org.eclipse.xtext.parsetree.reconstr.IInstanceDescription;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor;

import de.itemis.xtext.antlr.splitting.services.SimpleExpressionsGrammarAccess;

import com.google.inject.Inject;

public class SimpleExpressionsParsetreeConstructor extends AbstractParseTreeConstructor {
		
	@Inject
	private SimpleExpressionsGrammarAccess grammarAccess;
	
	@Override	
	public SimpleExpressionsGrammarAccess getGrammarAccess() {
		return grammarAccess;
	}

	@Override
	protected AbstractToken getRootToken(IInstanceDescription inst) {
		return new ThisRootNode(inst);	
	}
	
protected class ThisRootNode extends RootToken {
	public ThisRootNode(IInstanceDescription inst) {
		super(inst);
	}
	
	@Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IfCondition_Group(this, this, 0, inst);
			case 1: return new Expression_Group(this, this, 1, inst);
			case 2: return new AndExpression_Group(this, this, 2, inst);
			case 3: return new Comparison_Group(this, this, 3, inst);
			case 4: return new PrefixExpression_Alternatives(this, this, 4, inst);
			case 5: return new Atom_Alternatives(this, this, 5, inst);
			case 6: return new NumberLiteral_ValueAssignment(this, this, 6, inst);
			case 7: return new ParenthesizedExpression_Group(this, this, 7, inst);
			case 8: return new MethodCall_ValueAssignment(this, this, 8, inst);
			default: return null;
		}	
	}	
}
	

/************ begin Rule IfCondition ****************
 *
 * IfCondition:
 *   elseif?="else"? "if" "(" condition=Expression ")" "{";
 *
 **/

// elseif?="else"? "if" "(" condition=Expression ")" "{"
protected class IfCondition_Group extends GroupToken {
	
	public IfCondition_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getIfConditionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IfCondition_LeftCurlyBracketKeyword_5(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getIfConditionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// elseif?="else"?
protected class IfCondition_ElseifAssignment_0 extends AssignmentToken  {
	
	public IfCondition_ElseifAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getIfConditionAccess().getElseifAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("elseif",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("elseif");
		if(Boolean.TRUE.equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getIfConditionAccess().getElseifElseKeyword_0_0();
			return obj;
		}
		return null;
	}

}

// "if"
protected class IfCondition_IfKeyword_1 extends KeywordToken  {
	
	public IfCondition_IfKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getIfConditionAccess().getIfKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IfCondition_ElseifAssignment_0(parent, this, 0, inst);
			default: return parent.createParentFollower(this, index, index - 1, inst);
		}	
	}	
		
}

// "("
protected class IfCondition_LeftParenthesisKeyword_2 extends KeywordToken  {
	
	public IfCondition_LeftParenthesisKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getIfConditionAccess().getLeftParenthesisKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IfCondition_IfKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// condition=Expression
protected class IfCondition_ConditionAssignment_3 extends AssignmentToken  {
	
	public IfCondition_ConditionAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getIfConditionAccess().getConditionAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("condition",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("condition");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getIfConditionAccess().getConditionExpressionParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new IfCondition_LeftParenthesisKeyword_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ")"
protected class IfCondition_RightParenthesisKeyword_4 extends KeywordToken  {
	
	public IfCondition_RightParenthesisKeyword_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getIfConditionAccess().getRightParenthesisKeyword_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IfCondition_ConditionAssignment_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "{"
protected class IfCondition_LeftCurlyBracketKeyword_5 extends KeywordToken  {
	
	public IfCondition_LeftCurlyBracketKeyword_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getIfConditionAccess().getLeftCurlyBracketKeyword_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IfCondition_RightParenthesisKeyword_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule IfCondition ****************/


/************ begin Rule Expression ****************
 *
 * Expression:
 *   AndExpression ({OrExpression.left=current} "||" right=AndExpression)*;
 *
 **/

// AndExpression ({OrExpression.left=current} "||" right=AndExpression)*
protected class Expression_Group extends GroupToken {
	
	public Expression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_Group_1(parent, this, 0, inst);
			case 1: return new Expression_AndExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// AndExpression
protected class Expression_AndExpressionParserRuleCall_0 extends RuleCallToken {
	
	public Expression_AndExpressionParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getExpressionAccess().getAndExpressionParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(AndExpression_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getAndExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ({OrExpression.left=current} "||" right=AndExpression)*
protected class Expression_Group_1 extends GroupToken {
	
	public Expression_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getExpressionAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_RightAssignment_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {OrExpression.left=current}
protected class Expression_OrExpressionLeftAction_1_0 extends ActionToken  {

	public Expression_OrExpressionLeftAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getExpressionAccess().getOrExpressionLeftAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_Group_1(parent, this, 0, inst);
			case 1: return new Expression_AndExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getExpressionAccess().getOrExpressionLeftAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("left", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("left")) return null;
		return getDescr((EObject) val);
	}
}

// "||"
protected class Expression_VerticalLineVerticalLineKeyword_1_1 extends KeywordToken  {
	
	public Expression_VerticalLineVerticalLineKeyword_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getExpressionAccess().getVerticalLineVerticalLineKeyword_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_OrExpressionLeftAction_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// right=AndExpression
protected class Expression_RightAssignment_1_2 extends AssignmentToken  {
	
	public Expression_RightAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getExpressionAccess().getRightAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("right",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("right");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAndExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getExpressionAccess().getRightAndExpressionParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Expression_VerticalLineVerticalLineKeyword_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule Expression ****************/


/************ begin Rule AndExpression ****************
 *
 * AndExpression returns Expression:
 *   Comparison ({AndExpression.left=current} "&&" right=Comparison)*;
 *
 **/

// Comparison ({AndExpression.left=current} "&&" right=Comparison)*
protected class AndExpression_Group extends GroupToken {
	
	public AndExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAndExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndExpression_Group_1(parent, this, 0, inst);
			case 1: return new AndExpression_ComparisonParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAndExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// Comparison
protected class AndExpression_ComparisonParserRuleCall_0 extends RuleCallToken {
	
	public AndExpression_ComparisonParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAndExpressionAccess().getComparisonParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Comparison_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Comparison_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getComparisonRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ({AndExpression.left=current} "&&" right=Comparison)*
protected class AndExpression_Group_1 extends GroupToken {
	
	public AndExpression_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAndExpressionAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndExpression_RightAssignment_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {AndExpression.left=current}
protected class AndExpression_AndExpressionLeftAction_1_0 extends ActionToken  {

	public AndExpression_AndExpressionLeftAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getAndExpressionAccess().getAndExpressionLeftAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndExpression_Group_1(parent, this, 0, inst);
			case 1: return new AndExpression_ComparisonParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getAndExpressionAccess().getAndExpressionLeftAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("left", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("left")) return null;
		return getDescr((EObject) val);
	}
}

// "&&"
protected class AndExpression_AmpersandAmpersandKeyword_1_1 extends KeywordToken  {
	
	public AndExpression_AmpersandAmpersandKeyword_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getAndExpressionAccess().getAmpersandAmpersandKeyword_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndExpression_AndExpressionLeftAction_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// right=Comparison
protected class AndExpression_RightAssignment_1_2 extends AssignmentToken  {
	
	public AndExpression_RightAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAndExpressionAccess().getRightAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Comparison_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("right",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("right");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getComparisonRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getAndExpressionAccess().getRightComparisonParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new AndExpression_AmpersandAmpersandKeyword_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule AndExpression ****************/


/************ begin Rule Comparison ****************
 *
 * Comparison returns Expression:
 *   PrefixExpression ({Comparison.left=current} operator=( "==" | "<=" | ">=" ) right=
 *   PrefixExpression)?;
 *
 **/

// PrefixExpression ({Comparison.left=current} operator=( "==" | "<=" | ">=" ) right=
// PrefixExpression)?
protected class Comparison_Group extends GroupToken {
	
	public Comparison_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getComparisonAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Comparison_Group_1(parent, this, 0, inst);
			case 1: return new Comparison_PrefixExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getComparisonRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// PrefixExpression
protected class Comparison_PrefixExpressionParserRuleCall_0 extends RuleCallToken {
	
	public Comparison_PrefixExpressionParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getComparisonAccess().getPrefixExpressionParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PrefixExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(PrefixExpression_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getPrefixExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ({Comparison.left=current} operator=( "==" | "<=" | ">=" ) right=PrefixExpression)?
protected class Comparison_Group_1 extends GroupToken {
	
	public Comparison_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getComparisonAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Comparison_RightAssignment_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {Comparison.left=current}
protected class Comparison_ComparisonLeftAction_1_0 extends ActionToken  {

	public Comparison_ComparisonLeftAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getComparisonAccess().getComparisonLeftAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Comparison_PrefixExpressionParserRuleCall_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getComparisonAccess().getComparisonLeftAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("left", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("left")) return null;
		return getDescr((EObject) val);
	}
}

// operator=( "==" | "<=" | ">=" )
protected class Comparison_OperatorAssignment_1_1 extends AssignmentToken  {
	
	public Comparison_OperatorAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getComparisonAccess().getOperatorAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Comparison_ComparisonLeftAction_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operator",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operator");
		if("==".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getComparisonAccess().getOperatorEqualsSignEqualsSignKeyword_1_1_0_0();
			return obj;
		}
		if("<=".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getComparisonAccess().getOperatorLessThanSignEqualsSignKeyword_1_1_0_1();
			return obj;
		}
		if(">=".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getComparisonAccess().getOperatorGreaterThanSignEqualsSignKeyword_1_1_0_2();
			return obj;
		}
		return null;
	}

}

// right=PrefixExpression
protected class Comparison_RightAssignment_1_2 extends AssignmentToken  {
	
	public Comparison_RightAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getComparisonAccess().getRightAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PrefixExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("right",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("right");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getPrefixExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getComparisonAccess().getRightPrefixExpressionParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Comparison_OperatorAssignment_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule Comparison ****************/


/************ begin Rule PrefixExpression ****************
 *
 * PrefixExpression returns Expression:
 *   {NotExpression} "!" expression=Atom|Atom;
 *
 **/

// {NotExpression} "!" expression=Atom|Atom
protected class PrefixExpression_Alternatives extends AlternativesToken {

	public PrefixExpression_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getPrefixExpressionAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PrefixExpression_Group_0(parent, this, 0, inst);
			case 1: return new PrefixExpression_AtomParserRuleCall_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getPrefixExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {NotExpression} "!" expression=Atom
protected class PrefixExpression_Group_0 extends GroupToken {
	
	public PrefixExpression_Group_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getPrefixExpressionAccess().getGroup_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PrefixExpression_ExpressionAssignment_0_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {NotExpression}
protected class PrefixExpression_NotExpressionAction_0_0 extends ActionToken  {

	public PrefixExpression_NotExpressionAction_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getPrefixExpressionAccess().getNotExpressionAction_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getPrefixExpressionAccess().getNotExpressionAction_0_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// "!"
protected class PrefixExpression_ExclamationMarkKeyword_0_1 extends KeywordToken  {
	
	public PrefixExpression_ExclamationMarkKeyword_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getPrefixExpressionAccess().getExclamationMarkKeyword_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PrefixExpression_NotExpressionAction_0_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// expression=Atom
protected class PrefixExpression_ExpressionAssignment_0_2 extends AssignmentToken  {
	
	public PrefixExpression_ExpressionAssignment_0_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPrefixExpressionAccess().getExpressionAssignment_0_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Atom_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("expression",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("expression");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAtomRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getPrefixExpressionAccess().getExpressionAtomParserRuleCall_0_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new PrefixExpression_ExclamationMarkKeyword_0_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// Atom
protected class PrefixExpression_AtomParserRuleCall_1 extends RuleCallToken {
	
	public PrefixExpression_AtomParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrefixExpressionAccess().getAtomParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Atom_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Atom_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getAtomRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule PrefixExpression ****************/


/************ begin Rule Atom ****************
 *
 * Atom returns Expression:
 *   ParenthesizedExpression|NumberLiteral|MethodCall;
 *
 **/

// ParenthesizedExpression|NumberLiteral|MethodCall
protected class Atom_Alternatives extends AlternativesToken {

	public Atom_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getAtomAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Atom_ParenthesizedExpressionParserRuleCall_0(parent, this, 0, inst);
			case 1: return new Atom_NumberLiteralParserRuleCall_1(parent, this, 1, inst);
			case 2: return new Atom_MethodCallParserRuleCall_2(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAtomRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// ParenthesizedExpression
protected class Atom_ParenthesizedExpressionParserRuleCall_0 extends RuleCallToken {
	
	public Atom_ParenthesizedExpressionParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAtomAccess().getParenthesizedExpressionParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParenthesizedExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(ParenthesizedExpression_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getParenthesizedExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// NumberLiteral
protected class Atom_NumberLiteralParserRuleCall_1 extends RuleCallToken {
	
	public Atom_NumberLiteralParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAtomAccess().getNumberLiteralParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new NumberLiteral_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(NumberLiteral_ValueAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getNumberLiteralRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// MethodCall
protected class Atom_MethodCallParserRuleCall_2 extends RuleCallToken {
	
	public Atom_MethodCallParserRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAtomAccess().getMethodCallParserRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MethodCall_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(MethodCall_ValueAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getMethodCallRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule Atom ****************/


/************ begin Rule NumberLiteral ****************
 *
 * NumberLiteral:
 *   value=INT;
 *
 **/

// value=INT
protected class NumberLiteral_ValueAssignment extends AssignmentToken  {
	
	public NumberLiteral_ValueAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getNumberLiteralAccess().getValueAssignment();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getNumberLiteralRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.LRC;
			element = grammarAccess.getNumberLiteralAccess().getValueINTTerminalRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule NumberLiteral ****************/


/************ begin Rule ParenthesizedExpression ****************
 *
 * ParenthesizedExpression returns Expression:
 *   "(" Expression ")";
 *
 **/

// "(" Expression ")"
protected class ParenthesizedExpression_Group extends GroupToken {
	
	public ParenthesizedExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getParenthesizedExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParenthesizedExpression_RightParenthesisKeyword_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getParenthesizedExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "("
protected class ParenthesizedExpression_LeftParenthesisKeyword_0 extends KeywordToken  {
	
	public ParenthesizedExpression_LeftParenthesisKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getParenthesizedExpressionAccess().getLeftParenthesisKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// Expression
protected class ParenthesizedExpression_ExpressionParserRuleCall_1 extends RuleCallToken {
	
	public ParenthesizedExpression_ExpressionParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getParenthesizedExpressionAccess().getExpressionParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Expression_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParenthesizedExpression_LeftParenthesisKeyword_0(parent, next, actIndex, inst);
			default: return null;
		}	
	}	
}

// ")"
protected class ParenthesizedExpression_RightParenthesisKeyword_2 extends KeywordToken  {
	
	public ParenthesizedExpression_RightParenthesisKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getParenthesizedExpressionAccess().getRightParenthesisKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParenthesizedExpression_ExpressionParserRuleCall_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule ParenthesizedExpression ****************/


/************ begin Rule MethodCall ****************
 *
 * MethodCall:
 *   value=MethodCallLiteral;
 *
 **/

// value=MethodCallLiteral
protected class MethodCall_ValueAssignment extends AssignmentToken  {
	
	public MethodCall_ValueAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getMethodCallAccess().getValueAssignment();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getMethodCallRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getMethodCallAccess().getValueMethodCallLiteralParserRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule MethodCall ****************/




}
