/*******************************************************************************
 * Copyright (c) 2008 itemis AG (http://www.itemis.eu) and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 *******************************************************************************/
import xtext;
import emf;

extension org::eclipse::xtext::Properties reexport;
extension org::eclipse::xtext::grammaraccess::GrammarAccess reexport;
extension org::eclipse::xtext::Extensions reexport;
extension org::eclipse::xtext::GrammarUtil reexport;
extension org::eclipse::xtend::util::stdlib::io;

ruleName(ParserRule this) : !terminal ? 'rule'+name : "RULE_" + name.toUpperCase();
ruleName(LexerRule this) : 'RULE_'+name.toUpperCase();
ruleName(AbstractRule this) : error("Unsupported");

entryRuleName(ParserRule this) : 'entryRule'+name;


typeName(Action this) : typeName.type.name;
typeName(AbstractRule this) : type.type.name;

setOrAdd(Action this) : if operator=='+=' then 'add' else 'set';


setOrAdd(Assignment this) : if operator=='+=' then 'add' else 'set';

isCalled(ParserRule this) :
	let x = grammar().allParserRules() :
		x.indexOf(this)==0 || 
		x.containingGrammar().eAllContents.flatten().typeSelect(RuleCall).select(call|call.rule!=null).rule.name.contains(this.name);

localVar(Assignment this) : 'lv_'+feature + '_' + containingParserRule().contentsAsList().indexOf(this);
localVar(RuleCall this) : 'this_'+rule.name + '_' + containingParserRule().contentsAsList().indexOf(this);

List[AbstractElement] contentsAsList(xtext::ParserRule this):
	alternatives.contentsAsList();
	
List[AbstractElement] contentsAsList(xtext::AbstractElement this):
	{this};
	
List[AbstractElement] contentsAsList(xtext::Alternatives this):
	this.groups.contentsAsList();

List[AbstractElement] contentsAsList(xtext::Group this):
	this.abstractTokens.contentsAsList();
	
toStringLiteral(xtext::AbstractElement this) :
	"null";
	
String toJavaString(String this):
	JAVA org.eclipse.xtext.util.Strings.convertToJavaString(java.lang.String);

toStringLiteral(RuleCall this) :
	rule!=null ? '"'+this.rule.name+'"' :  "null";

toStringLiteral(Keyword this) :
	'"'+this.value.toJavaString()+'"';
	
String toLexerBody(ParserRule this):
	JAVA de.itemis.xtext.antlr.TerminalRuleToLexerBody.toLexerBody(org.eclipse.xtext.ParserRule);

String objectURI(Grammar grammar, emf::EObject object) :
	JAVA de.itemis.xtext.antlr.AntlrGrammarGenUtil.getClasspathURI(org.eclipse.xtext.Grammar, org.eclipse.emf.ecore.EObject);

mustBeParenthesized(AbstractElement this) : true;
mustBeParenthesized(Group this) : true;
mustBeParenthesized(Alternatives this) : true;
mustBeParenthesized(Keyword this) : cardinality!=null;
mustBeParenthesized(RuleCall this) : cardinality!=null;

String grammarElementAccess(EObject object):
	error("grammarElementAccess for: " + object.toString()); 
	
String grammarElementAccess(AbstractRule rule):
	rule.gaRuleAccessor() + ".getRule()"; 

String grammarElementAccess(AbstractElement element):
	gaRuleElementAccessor(element);

List[String] initialHiddenTokens(Grammar this):
  if (definesHiddenTokens) then 
  	hiddenTokens.ruleName() 
  else if (getSuperGrammar() != null) then 
  	initialHiddenTokens(getSuperGrammar()) 
  else {};
